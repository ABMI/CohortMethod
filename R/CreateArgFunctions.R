# This file has been autogenerated. Do not change by hand. 

#' Create a parameter object for the function getDbCohortMethodData
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param washoutWindow                    The mininum required continuous observation time prior to
#'                                         indexdate for a person to be included in the cohort.
#' @param indicationLookbackWindow         NA
#' @param studyStartDate                   A calendar date specifying the minimum date that a cohort
#'                                         indexdate can appear. Date format is 'yyyymmdd'.
#' @param studyEndDate                     A calendar date specifying the maximum date that a cohort
#'                                         indexdate can appear. Date format is 'yyyymmdd'.
#' @param exclusionConceptIds              A list of CONCEPT_IDs used to restrict the cohorts, based on
#'                                         anydescendant conditions/drugs/procedures occurring at least
#'                                         onceanytime prior to the cohort index date.
#' @param outcomeConditionTypeConceptIds   A list of TYPE_CONCEPT_ID values that will restrictcondition
#'                                         occurrences.  Only applicable if outcomeTable
#'                                         =CONDITION_OCCURRENCE.
#' @param excludeDrugsFromCovariates       Should the target and comparator drugs (and their
#'                                         descendantconcepts) be excluded from the covariates? Note
#'                                         that this willwork if the drugs are actualy drug concept IDs
#'                                         (and not cohortIDs).
#' @param covariateSettings                An object of type covariateSettings as created using
#'                                         thecreateCovariateSettings function in
#'                                         thePatientLevelPrediction package..
#'
#' @export
createGetDbCohortMethodDataArgs <- function(washoutWindow = 183,
                                            indicationLookbackWindow = 183,
                                            studyStartDate = "",
                                            studyEndDate = "",
                                            exclusionConceptIds = c(),
                                            outcomeConditionTypeConceptIds = c(),
                                            excludeDrugsFromCovariates = TRUE,
                                            covariateSettings) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createGetDbCohortMethodDataArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}

#' Create a parameter object for the function createPs
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param excludeCovariateIds     Exclude these covariates from the propensity model.
#' @param stopOnHighCorrelation   If true, the function will test each covariate for correlation with
#'                                thetreatment assignment. If any covariate has an unusually high
#'                                correlation(either positive or negative), this will be reported and
#'                                the functionwill stop.
#' @param prior                   The prior used to fit the model. See createPriorfor details.
#' @param control                 The control object used to control the cross-validation used
#'                                todetermine the hyperparameters of the prior (if applicable).
#'                                SeecreateControl for details.
#'
#' @export
createCreatePsArgs <- function(excludeCovariateIds = NULL,
                               stopOnHighCorrelation = TRUE,
                               prior = createPrior("laplace",
                                                   exclude = c(0),
                                                   useCrossValidation = TRUE),
                               control = createControl(noiseLevel = "silent",
                                                       cvType = "auto",
                                                       startingVariance = 0.1)) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createCreatePsArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}

#' Create a parameter object for the function trimByPs
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param trimFraction   This fraction will be removed from each treatment group. In the
#'                       treatmentgroup, persons with the highest propensity scores will be removed, in
#'                       thecomparator group person with the lowest scores will be removed.
#'
#' @export
createTrimByPsArgs <- function(trimFraction = 0.05) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createTrimByPsArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}

#' Create a parameter object for the function trimByPsToEquipoise
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param bounds   The upper and lower bound on the preference score for keeping persons
#'
#' @export
createTrimByPsToEquipoiseArgs <- function(bounds = c(0.25, 0.75)) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createTrimByPsToEquipoiseArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}

#' Create a parameter object for the function matchOnPs
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param caliper                 The caliper for matching. A caliper is the distance which
#'                                isacceptable for any match. Observations which are outside of
#'                                thecaliper are dropped. A caliper of 0 means no caliper is used.
#' @param caliperScale            The scale on which the caliper is defined. Two scales are
#'                                supported:caliperScale = 'propensity score' or caliperScale
#'                                ='standardized'. On the standardized scale, the caliper isinterpreted
#'                                in standard deviations of the propensity scoredistribution.
#' @param maxRatio                The maximum number of persons int the comparator arm to be matched
#'                                toeach person in the treatment arm. A maxRatio of 0 means no
#'                                maximum:all comparators will be assigned to a treated person.
#' @param stratificationColumns   Names or numbers of one or more columns in the data data.frameon
#'                                which subjects should be stratified prior to matching. No personswill
#'                                be matched with persons outside of the strata identified by thevalues
#'                                in these columns.
#'
#' @export
createMatchOnPsArgs <- function(caliper = 0.25,
                                caliperScale = "standardized",
                                maxRatio = 1,
                                stratificationColumns = c()) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createMatchOnPsArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}

#' Create a parameter object for the function matchOnPsAndCovariates
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param caliper        The caliper for matching. A caliper is the distance which is acceptablefor any
#'                       match. Observations which are outside of the caliper are dropped.A caliper of
#'                       0 means no caliper is used.
#' @param caliperScale   The scale on which the caliper is defined. Two scales
#'                       aresupported:caliperScale = 'propensity score' orcaliperScale =
#'                       'standardized'. On the standardized scale, thecaliper is interpreted in
#'                       standard deviations of the propensity scoredistribution.
#' @param maxRatio       The maximum number of persons int the comparator arm to be matched to
#'                       eachperson in the treatment arm. A maxRatio of 0 means no maximum:
#'                       allcomparators will be assigned to a treated person.
#' @param covariateIds   One or more covariate IDs in the cohortMethodData object on whichsubjects
#'                       should be also matched.
#'
#' @export
createMatchOnPsAndCovariatesArgs <- function(caliper = 0.25,
                                             caliperScale = "standardized",
                                             maxRatio = 1,
                                             covariateIds) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createMatchOnPsAndCovariatesArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}

#' Create a parameter object for the function stratifyByPs
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param numberOfStrata          How many strata? The boundaries of the strata are
#'                                automaticallydefined to contain equal numbers of treated persons.
#' @param stratificationColumns   Names of one or more columns in the data data.frame on whichsubjects
#'                                should also be stratified in addition to stratification onpropensity
#'                                score.
#'
#' @export
createStratifyByPsArgs <- function(numberOfStrata = 5, stratificationColumns = c()) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createStratifyByPsArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}

#' Create a parameter object for the function stratifyByPsAndCovariates
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param numberOfStrata   Into how many strata should the propensity score be divided? Theboundaries
#'                         of the strata are automatically defined to contain equalnumbers of treated
#'                         persons.
#' @param covariateIds     One or more covariate IDs in the cohortMethodData object on whichsubjects
#'                         should also be stratified.
#'
#' @export
createStratifyByPsAndCovariatesArgs <- function(numberOfStrata = 5, covariateIds) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createStratifyByPsAndCovariatesArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}

#' Create a parameter object for the function fitOutcomeModel
#'
#' @details
#' Create an object defining the parameter values.
#'
#' @param stratifiedCox          Specifically for Cox regressions: specify whether to use the
#'                               stratadefined in subPopulation in the analysis. For Poissonregression
#'                               and logistic regression, this is implied in 'clr' and'cpr'.
#' @param riskWindowStart        The start of the risk window (in days) relative to the index data.
#' @param riskWindowEnd          The end of the risk window (in days) relative to the index data (+days
#'                               of exposure if the addExposureDaysToEnd parameter isspecified).
#' @param addExposureDaysToEnd   Add the length of exposure the risk window?
#' @param useCovariates          Whether to use the covariate matrix in the cohortMethodData in
#'                               theoutcome model.
#' @param fitModel               If false, the model will not be fit, and only summary statistics
#'                               areavailable.
#' @param modelType              The type of model to be fitted. See details for options.
#' @param prior                  The prior used to fit the model. SeecreatePrior for details.
#' @param control                The control object used to control the cross-validation used
#'                               todetermine the hyperparameters of the prior (if applicable).
#'                               SeecreateControl for details.
#'
#' @export
createFitOutcomeModelArgs <- function(stratifiedCox = TRUE,
                                      riskWindowStart = 0,
                                      riskWindowEnd = 9999,
                                      addExposureDaysToEnd = FALSE,
                                      useCovariates = TRUE,
                                      fitModel = TRUE,
                                      modelType = "cox",
                                      prior = createPrior("laplace", useCrossValidation = TRUE),
                                      control = createControl(cvType = "auto",
                                                              startingVariance = 0.1,
                                                              selectorType = "byPid",
                                                              noiseLevel = "quiet")) {
  # First: get default values:
  analysis <- list()
  for (name in names(formals(createFitOutcomeModelArgs))) {
    analysis[[name]] <- get(name)
  }
  # Second: overwrite defaults with actual values:
  values <- lapply(as.list(match.call())[-1], function(x) eval(x, envir = sys.frame(-3)))
  for (name in names(values)) {
    if (name %in% names(analysis))
      analysis[[name]] <- values[[name]]
  }
  class(analysis) <- "args"
  return(analysis)
}
