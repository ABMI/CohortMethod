# @file CohortMethod.R
#
# Copyright 2020 Observational Health Data Sciences and Informatics
#
# This file is part of CohortMethod
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Create an outcome model, and compute the relative risk
#'
#' @details
#' IPTW estimates the average treatment effect using stabilized inverse propensity scores (Xu et al. 2010).
#'
#' @description
#' Create an outcome model, and computes the relative risk
#'

#' @param population            A population object generated by [createStudyPopulation()],
#'                              potentially filtered by other functions.
#'
#' @param cohortMethodData      An object of type [CohortMethodData] as generated using
#'                              [getDbCohortMethodData()]. Can be omitted if not using covariates and
#'                              not using interaction terms.
#' @param modelType             The type of outcome model that will be used. Possible values are
#'                              "logistic", "poisson", or "cox".
#' @param stratified            Should the regression be conditioned on the strata defined in the
#'                              population object (e.g. by matching or stratifying on propensity
#'                              scores)?
#' @param useCovariates         Whether to use the covariates in the `cohortMethodData`
#'                              object in the outcome model.
#' @param inversePtWeighting    Use inverse probability of treatment weigting (IPTW)? See details.
#' @param interactionCovariateIds  An optional vector of covariate IDs to use to estimate interactions
#'                                 with the main treatment effect.
#' @param excludeCovariateIds   Exclude these covariates from the outcome model.
#' @param includeCovariateIds   Include only these covariates in the outcome model.
#' @param prior                 The prior used to fit the model. See [Cyclops::createPrior()]
#'                              for details.
#' @param control               The control object used to control the cross-validation used to
#'                              determine the hyperparameters of the prior (if applicable). See
#'                              [Cyclops::createControl()] for details.
#'
#' @references
#' Xu S, Ross C, Raebel MA, Shetterly S, Blanchette C, Smith D. Use of stabilized inverse propensity scores
#' as weights to directly estimate relative risk and its confidence intervals. Value Health.
#' 2010;13(2):273â€“277. doi:10.1111/j.1524-4733.2009.00671.x
#'
#' @return
#' An object of class `OutcomeModel`. Generic function `summary`, `coef`, and
#' `confint` are available.
#'
#' @export
fitOutcomeModel <- function(population,
                            cohortMethodData = NULL,
                            modelType = "logistic",
                            stratified = FALSE,
                            useCovariates = FALSE,
                            inversePtWeighting = FALSE,
                            interactionCovariateIds = c(),
                            excludeCovariateIds = c(),
                            includeCovariateIds = c(),
                            prior = createPrior("laplace", useCrossValidation = TRUE),
                            control = createControl(cvType = "auto",
                                                    seed = 1,
                                                    startingVariance = 0.01,
                                                    tolerance = 2e-07,
                                                    cvRepetitions = 10,
                                                    noiseLevel = "quiet")) {
  if (stratified && nrow(population) > 0 && is.null(population$stratumId))
    stop("Requested stratified analysis, but no stratumId column found in population. Please use matchOnPs or stratifyByPs to create strata.")
  if (is.null(population$outcomeCount))
    stop("No outcome variable found in population object. Use createStudyPopulation to create variable.")
  if (is.null(cohortMethodData) && useCovariates)
    stop("Requested all covariates for model, but no cohortMethodData object specified")
  if (is.null(cohortMethodData) && length(interactionCovariateIds) != 0)
    stop("Requesting interaction terms in model, but no cohortMethodData object specified")
  if (any(excludeCovariateIds %in% interactionCovariateIds))
    stop("Can't exclude covariates that are to be used for interaction terms")
  if (inversePtWeighting && is.null(population$propensityScore))
    stop("Requested inverse probability weighting, but no propensity scores are provided. Use createPs to generate them")
  if (modelType != "logistic" && modelType != "poisson" && modelType != "cox")
    stop("Unknown modelType '", modelType, "', please choose either 'logistic', 'poisson', or 'cox'")
  ParallelLogger::logTrace("Fitting outcome model")

  start <- Sys.time()
  treatmentEstimate <- NULL
  interactionEstimates <- NULL
  mainEffectEstimates <- NULL
  mainEffectTerms <- NULL
  coefficients <- NULL
  fit <- NULL
  priorVariance <- NULL
  treatmentVarId <- NA
  subgroupCounts <- NULL
  logLikelihoodProfile <- NULL
  status <- "NO MODEL FITTED"

  metaData <- attr(population, "metaData")

  population <- rename(population, y = .data$outcomeCount)
  if (!stratified) {
    population$stratumId <- NULL
  }
  population$time <- population$timeAtRisk
  if (modelType == "cox") {
    population$y[population$y != 0] <- 1
    population$time <- population$survivalTime
  } else if (modelType == "logistic") {
    population$y[population$y != 0] <- 1
  }

  if (nrow(population) == 0) {
    status <- "NO SUBJECTS IN POPULATION, CANNOT FIT"
  } else if (sum(population$y) == 0) {
    status <- "NO OUTCOMES FOUND FOR POPULATION, CANNOT FIT"
  } else {
    # Informative population ---------------------------------------------------------
    if (stratified) {
      informativePopulation <- population %>%
        filter(.data$y != 0) %>%
        group_by(.data$stratumId) %>%
        select(.data$stratumId) %>%
        ungroup() %>%
        inner_join(population, by = "stratumId")
    } else {
      informativePopulation <- population
    }
    if (inversePtWeighting) {
      informativePopulation$weight <- computeWeights(informativePopulation)
    } else {
      informativePopulation$weight <- NULL
    }
    columns <- c("rowId", "y", "treatment")
    if (stratified) {
      columns <- c(columns, "stratumId")
    }
    if (modelType == "poisson" || modelType == "cox") {
      columns <- c(columns, "time")
    }
    if (inversePtWeighting) {
      columns <- c(columns, "weight")
    }
    informativePopulation <- informativePopulation[, columns]

    if (sum(informativePopulation$treatment == 1) == 0 || sum(informativePopulation$treatment == 0) == 0) {
      status <- "NO STRATA WITH BOTH TARGET, COMPARATOR, AS WELL AS THE OUTCOME. CANNOT FIT"
    } else {

      if (useCovariates) {
        # Add covariates ---------------------------------------------------------------------------------
        covariateData <- filterAndTidyCovariates(cohortMethodData = cohortMethodData,
                                                 includeRowIds = informativePopulation$rowId,
                                                 includeCovariateIds = includeCovariateIds,
                                                 excludeCovariateIds = excludeCovariateIds)
        metaData$deletedRedundantCovariateIdsForOutcomeModel <- attr(covariateData, "metaData")$deletedRedundantCovariateIds
        metaData$deletedInfrequentCovariateIdsForOutcomeModel <- attr(covariateData, "metaData")$deletedInfrequentCovariateIds

        mainEffectTerms <- covariateData$covariates %>%
          distinct(.data$covariateId) %>%
          inner_join(covariateData$covariateRef, by = "covariateId") %>%
          select(id = .data$covariateId, name = .data$covariateName) %>%
          collect()

        treatmentVarId <- cohortMethodData$covariates %>%
          summarise(value = max(.data$covariateId, na.rm = TRUE)) %>%
          pull() + 1

        treatmentCovariate <- informativePopulation %>%
          select(.data$rowId, covariateValue = .data$treatment) %>%
          mutate(covariateId = treatmentVarId)

        appendToTable(covariateData$covariates, treatmentCovariate)

        if (stratified || modelType == "cox") {
          prior$exclude <- treatmentVarId  # Exclude treatment variable from regularization
        } else {
          prior$exclude <- c(0, treatmentVarId)  # Exclude treatment variable and intercept from regularization
        }

      } else {
        # Don't add covariates, only use treatment as covariate ----------------------------------------------
        treatmentVarId <- 1

        treatmentCovariate <- informativePopulation %>%
          select(.data$rowId, covariateValue = .data$treatment) %>%
          mutate(covariateId = treatmentVarId)

        covariateData <- Andromeda::andromeda(covariates = treatmentCovariate)

        prior <- createPrior("none")
      }

      # Interaction terms -----------------------------------------------------------------------------------
      interactionTerms <- NULL
      if (length(interactionCovariateIds) != 0) {
        idx <- ffbase::`%in%`(cohortMethodData$covariates$covariateId, ff::as.ff(interactionCovariateIds))
        if (ffbase::any.ff(idx)) {
          informativeIdx <- ff::clone.ff(idx)
          informativeIdx[informativeIdx] <- informativeIdx[informativeIdx] &
            ffbase::`%in%`(cohortMethodData$covariates$rowId[informativeIdx], ff::as.ff(informativePopulation$rowId))
          if (!useCovariates) {  # TODO possible bug?  Should remove !?
            # Add covariates for main effects:
            if (ffbase::any.ff(informativeIdx)) {
              mainEffects <- cohortMethodData$covariates[informativeIdx, ]
              if (stratified) {
                mainEffects <- ffbase::merge.ffdf(mainEffects,
                                                  ff::as.ffdf(informativePopulation[, c("rowId", "stratumId")]))
              }
              covariates <- ffbase::ffdfappend(covariates, mainEffects)
            }
          }
          # Add covariates for interaction terms:
          if (ffbase::any.ff(informativeIdx)) {
            interactionIdx <- ff::clone.ff(informativeIdx)
            interactionIdx[interactionIdx] <- informativeIdx[interactionIdx] & ffbase::`%in%`(cohortMethodData$covariates$rowId[interactionIdx],
                                                                                              ff::as.ff(informativePopulation$rowId[informativePopulation$treatment == 1]))
            if (ffbase::any.ff(interactionIdx)) {
              interactionNames <- ff::as.ram(cohortMethodData$covariateRef$covariateName[ffbase::ffmatch(ff::as.ff(interactionCovariateIds),
                                                                                                         cohortMethodData$covariateRef$covariateId)])
              interactionNames <- as.character(interactionNames) # Drops unused levels to save lots of space
              interactionTerms <- data.frame(covariateId = interactionCovariateIds,
                                             interactionId = treatmentVarId + 1:length(interactionCovariateIds),
                                             interactionName = paste("treatment", interactionNames, sep = " * "),
                                             stringsAsFactors = FALSE)

              interactionEffects <- cohortMethodData$covariates[interactionIdx, ]
              interactionEffects <- ffbase::merge.ffdf(interactionEffects,
                                                       ff::as.ffdf(interactionTerms[, c("covariateId", "interactionId")]))
              interactionEffects <- ff::ffdf(rowId = interactionEffects$rowId,
                                             covariateId = interactionEffects$interactionId,
                                             covariateValue = interactionEffects$covariateValue)
              if (stratified) {
                interactionEffects <- ffbase::merge.ffdf(interactionEffects,
                                                         ff::as.ffdf(informativePopulation[, c("rowId", "stratumId")]))
              }
              covariates <- ffbase::ffdfappend(covariates, interactionEffects)
              interactionTerms <- interactionTerms[interactionTerms$interactionId %in% ff::as.ram(ffbase::unique.ff(interactionEffects$covariateId)), ]
              if (nrow(interactionTerms) == 0) {
                interactionTerms <- NULL
              }

              # Compute counts for subgroups:
              subgroups <- cohortMethodData$covariates[idx, ]
              subgroups <- ffbase::merge.ffdf(subgroups,
                                              ff::as.ffdf(population[, c("rowId", "treatment", "time", "y", "subjectId")]))
              subgroupNames <- data.frame(name = interactionNames,
                                          covariateId = interactionCovariateIds)
              subgroupCovariateIds <- ff::as.ram(ffbase::unique.ff(subgroups$covariateId))

              createSubgroupCounts <- function(subgroupCovariateId) {
                subgroup <- ff::as.ram(subgroups[subgroups$covariateId == subgroupCovariateId, ])
                subPopulationCounts <- getCounts(subgroup, subgroupNames$name[subgroupNames$covariateId == subgroupCovariateId])
                subOutcomeCounts <- data.frame(targetOutcomePersons = length(unique(subgroup$subjectId[subgroup$treatment == 1 & subgroup$y != 0])),
                                               comparatorOutcomePersons = length(unique(subgroup$subjectId[subgroup$treatment == 0 & subgroup$y != 0])),
                                               targetOutcomeExposures = length(subgroup$subjectId[subgroup$treatment == 1 & subgroup$y != 0]),
                                               comparatorOutcomeExposures = length(subgroup$subjectId[subgroup$treatment == 0 & subgroup$y != 0]),
                                               targetOutcomes = sum(subgroup$y[subgroup$treatment == 1]),
                                               comparatorOutcomes = sum(subgroup$y[subgroup$treatment == 0]))
                subTimeAtRisk <- data.frame(targetDays = sum(subgroup$time[subgroup$treatment == 1]),
                                            comparatorDays = sum(subgroup$time[subgroup$treatment == 0]))
                counts <- cbind(subPopulationCounts, subOutcomeCounts, subTimeAtRisk)
                counts$subgroupCovariateId <- subgroupCovariateId
                return(counts)
              }

              subgroupCounts <- lapply(subgroupCovariateIds, createSubgroupCounts)
              subgroupCounts <- do.call("rbind", subgroupCounts)
            }
          }
        }
        if (useCovariates && !is.null(interactionTerms)) {
          prior$exclude <- unique(c(prior$exclude, interactionTerms$covariateId, interactionTerms$interactionId))
        }
      }

      # Fit model -------------------------------------------------------------------------------------------
      covariateData$outcomes <- informativePopulation
      outcomes <- covariateData$outcomes
      if (stratified) {
        covariates <- covariateData$covariates %>%
          inner_join(select(covariateData$outcomes, .data$rowId, .data$stratumId), by = "rowId")
      } else {
        covariates <- covariateData$covariates
      }
      cyclopsData <- Cyclops::convertToCyclopsData(outcomes = outcomes,
                                                   covariates = covariates,
                                                   addIntercept = (!stratified && !modelType == "cox"),
                                                   modelType = modelTypeToCyclopsModelType(modelType,
                                                                                           stratified),
                                                   checkSorting = TRUE,
                                                   checkRowIds = FALSE,
                                                   normalize = NULL,
                                                   quiet = TRUE)

      if (!is.null(interactionTerms)) {
        # Check separability:
        separability <- Cyclops::getUnivariableSeparability(cyclopsData)
        separability[as.character(treatmentVarId)] <- FALSE
        if (any(separability)) {
          removeCovariateIds <- as.numeric(names(separability)[separability])
          # Add main effects of separable interaction effects, and the other way around:
          removeCovariateIds <- unique(c(removeCovariateIds,
                                         interactionTerms$covariateId[interactionTerms$interactionId %in% removeCovariateIds]))
          removeCovariateIds <- unique(c(removeCovariateIds,
                                         interactionTerms$interactionId[interactionTerms$covariateId %in% removeCovariateIds]))
          covariates <- covariates[!ffbase::`%in%`(covariates$covariateId, removeCovariateIds), ]
          cyclopsData <- Cyclops::convertToCyclopsData(outcomes = outcomes,
                                                       covariates = covariates,
                                                       addIntercept = addIntercept,
                                                       modelType = modelTypeToCyclopsModelType(modelType,
                                                                                               stratified),
                                                       checkSorting = TRUE,
                                                       checkRowIds = FALSE,
                                                       normalize = NULL,
                                                       quiet = TRUE)
          warning("Separable interaction terms found and removed")
          ref <- interactionTerms[interactionTerms$interactionId %in% removeCovariateIds, ]
          ParallelLogger::logInfo("Separable interactions:")
          for (i in 1:nrow(ref))
            ParallelLogger::logInfo(paste(ref[i, ], collapse = "\t"))
          interactionTerms <- interactionTerms[!(interactionTerms$interactionId %in% removeCovariateIds), ]
          if (nrow(interactionTerms) == 0) {
            interactionTerms <- NULL
          }
        }
      }

      close(covariateData)

      if (prior$priorType != "none" && prior$useCrossValidation && control$selectorType == "byPid" &&
          length(unique(informativePopulation$stratumId)) < control$fold) {
        fit <- "NUMBER OF INFORMATIVE STRATA IS SMALLER THAN THE NUMBER OF CV FOLDS, CANNOT FIT"
      } else {
        fit <- tryCatch({
          Cyclops::fitCyclopsModel(cyclopsData, prior = prior, control = control)
        }, error = function(e) {
          e$message
        })
      }
      if (is.character(fit)) {
        status <- fit
      } else if (fit$return_flag == "ILLCONDITIONED") {
        status <- "ILL CONDITIONED, CANNOT FIT"
      } else if (fit$return_flag == "MAX_ITERATIONS") {
        status <- "REACHED MAXIMUM NUMBER OF ITERATIONS, CANNOT FIT"
      } else {
        status <- "OK"
        coefficients <- coef(fit)
        logRr <- coef(fit)[names(coef(fit)) == as.character(treatmentVarId)]
        ci <- tryCatch({
          confint(fit, parm = treatmentVarId, includePenalty = TRUE)
        }, error = function(e) {
          missing(e)  # suppresses R CMD check note
          c(0, -Inf, Inf)
        })
        if (identical(ci, c(0, -Inf, Inf)))
          status <- "ERROR COMPUTING CI"
        seLogRr <- (ci[3] - ci[2])/(2 * qnorm(0.975))
        treatmentEstimate <- tibble::tibble(logRr = logRr,
                                            logLb95 = ci[2],
                                            logUb95 = ci[3],
                                            seLogRr = seLogRr)
        priorVariance <- fit$variance[1]

        if (!is.null(mainEffectTerms)) {
          logRr <- coef(fit)[match(as.character(mainEffectTerms$id), names(coef(fit)))]
          if (prior$priorType == "none") {
            ci <- tryCatch({
              confint(fit, parm = mainEffectTerms$id, includePenalty = TRUE,
                      overrideNoRegularization = TRUE)
            }, error = function(e) {
              missing(e)  # suppresses R CMD check note
              t(array(c(0, -Inf, Inf), dim = c(3,nrow(mainEffectTerms))))
            })
          } else {
            ci <- t(array(c(0, -Inf, Inf), dim = c(3,nrow(mainEffectTerms))))
          }
          seLogRr <- (ci[ ,3] - ci[ ,2])/(2 * qnorm(0.975))
          mainEffectEstimates <- tibble::tibble(covariateId = mainEffectTerms$id,
                                                coariateName = mainEffectTerms$name,
                                                logRr = logRr,
                                                logLb95 = ci[ ,2],
                                                logUb95 = ci[ ,3],
                                                seLogRr = seLogRr)
        }

        if (!is.null(interactionTerms)) {
          logRr <- coef(fit)[match(as.character(interactionTerms$interactionId), names(coef(fit)))]
          ci <- tryCatch({
            confint(fit, parm = interactionTerms$interactionId, includePenalty = TRUE)
          }, error = function(e) {
            missing(e)  # suppresses R CMD check note
            t(array(c(0, -Inf, Inf), dim = c(3,nrow(interactionTerms))))
          })
          seLogRr <- (ci[ ,3] - ci[ ,2])/(2 * qnorm(0.975))
          interactionEstimates <- data.frame(covariateId = interactionTerms$covariateId,
                                             interactionName = interactionTerms$interactionName,
                                             logRr = logRr,
                                             logLb95 = ci[ ,2],
                                             logUb95 = ci[ ,3],
                                             seLogRr = seLogRr)
        }

        if (!is.null(control$profileLogLikelihood) && control$profileLogLikelihood) {
          x <- seq(log(0.1), log(10), length.out = 100) # TODO Evil magic numbers
          y <- Cyclops::getCyclopsProfileLogLikelihood(fit, parm = treatmentVarId, x)$value
          logLikelihoodProfile <- tibble::tibble(covariateId = treatmentVarId,
                                                 value = x,
                                                 logLikelihood = y
          )
        }
      }
    }
  }
  outcomeModel <- metaData
  outcomeModel$outcomeModelTreatmentVarId <- treatmentVarId
  outcomeModel$outcomeModelCoefficients <- coefficients
  outcomeModel$outcomeModelPriorVariance <- priorVariance
  outcomeModel$outcomeModelType <- modelType
  outcomeModel$outcomeModelStratified <- stratified
  outcomeModel$outcomeModelUseCovariates <- useCovariates
  outcomeModel$inversePtWeighting <- inversePtWeighting
  outcomeModel$outcomeModelTreatmentEstimate <- treatmentEstimate
  outcomeModel$outcomeModelmainEffectEstimates <- mainEffectEstimates
  if (length(interactionCovariateIds) != 0)
    outcomeModel$outcomeModelInteractionEstimates <- interactionEstimates
  outcomeModel$outcomeModelStatus <- status
  outcomeModel$populationCounts <- getCounts(population, "Population count")
  outcomeModel$outcomeCounts <- getOutcomeCounts(population)
  if (modelType == "poisson" || modelType == "cox") {
    outcomeModel$timeAtRisk <- getTimeAtRisk(population)
  }

  if (!is.null(subgroupCounts)) {
    outcomeModel$subgroupCounts <- subgroupCounts
  }
  if (!is.null(logLikelihoodProfile)) {
    outcomeModel$logLikelihoodProfile <- logLikelihoodProfile
  }
  class(outcomeModel) <- "OutcomeModel"
  delta <- Sys.time() - start
  ParallelLogger::logInfo(paste("Fitting outcome model took", signif(delta, 3), attr(delta, "units")))
  ParallelLogger::logDebug("Outcome model fitting status is: ", status)
  return(outcomeModel)
}

modelTypeToCyclopsModelType <- function(modelType, stratified) {
  if (modelType == "logistic") {
    if (stratified)
      return("clr") else return("lr")
  } else if (modelType == "poisson") {
    if (stratified)
      return("cpr") else return("pr")
  } else if (modelType == "cox") {
    return("cox")
  } else stop(paste("Unknown model type:", modelType))
}

filterAndTidyCovariates <- function(cohortMethodData,
                                    includeRowIds,
                                    includeCovariateIds,
                                    excludeCovariateIds) {
  covariates <- cohortMethodData$covariates %>%
    filter(.data$rowId %in% includeRowIds)

  if (length(includeCovariateIds) != 0) {
    covariates <- covariates %>%
      filter(.data$covariateId %in% includeCovariateIds)
  }
  if (length(excludeCovariateIds) != 0) {
    covariates <- covariates %>%
      filter(!.data$covariateId %in% includeCovariateIds)
  }
  filteredCovariateData <- Andromeda::andromeda(covariates = covariates,
                                                covariateRef = cohortMethodData$covariateRef,
                                                analysisRef = cohortMethodData$analysisRef)
  metaData <- attr(cohortMethodData, "metaData")
  metaData$populationSize <- length(includeRowIds)
  attr(filteredCovariateData, "metaData") <- metaData
  class(filteredCovariateData) <- "CovariateData"

  covariateData <- FeatureExtraction::tidyCovariateData(filteredCovariateData)
  close(filteredCovariateData)
  return(covariateData)
}

computeWeights <- function(informativePopulation) {
  # ATE:
  # informativePopulation$weight <- ifelse(informativePopulation$treatment == 1,
  #                                        1/informativePopulation$propensityScore,
  #                                        1/(1 - informativePopulation$propensityScore))

  # 'Stabilized' ATE:
  return(ifelse(informativePopulation$treatment == 1,
                mean(informativePopulation$treatment == 1)/informativePopulation$propensityScore,
                mean(informativePopulation$treatment == 0)/(1 - informativePopulation$propensityScore)))

  # ATT:
  # informativePopulation$weight <- ifelse(informativePopulation$treatment == 1,
  #                                        1,
  #                                        informativePopulation$propensityScore/(1 - informativePopulation$propensityScore))
}

getOutcomeCounts <- function(population) {
  return(tibble::tibble(targetPersons = length(unique(population$subjectId[population$treatment == 1 & population$y != 0])),
                        comparatorPersons = length(unique(population$subjectId[population$treatment == 0 & population$y != 0])),
                        targetExposures = length(population$subjectId[population$treatment == 1 & population$y != 0]),
                        comparatorExposures = length(population$subjectId[population$treatment == 0 & population$y != 0]),
                        targetOutcomes = sum(population$y[population$treatment == 1]),
                        comparatorOutcomes = sum(population$y[population$treatment == 0])))
}

getTimeAtRisk <- function(population) {
  return(tibble::tibble(targetDays = sum(population$time[population$treatment == 1]),
                        comparatorDays = sum(population$time[population$treatment == 0])))
}


#' @export
summary.OutcomeModel <- function(object, ...) {
  class(object) <- "summary.outcomeModel"
  return(object)
}

#' @export
print.summary.OutcomeModel <- function(x, ...) {
  print.OutcomeModel(x)

  writeLines("")
  writeLines("Population counts")
  d <- x$populationCounts
  row.names(d) <- "Count"
  d$description <- NULL
  printCoefmat(d)

  writeLines("")
  writeLines("Outcome counts")
  d <- x$outcomeCounts
  row.names(d) <- "Count"
  if (x$outcomeModelType != "poisson") {
    d$targetOutcomes <- NULL
    d$comparatorOutcomes <- NULL
  }
  printCoefmat(d)

  if (x$outcomeModelType == "poisson" || x$outcomeModelType == "cox") {
    writeLines("")
    writeLines("Time at risk")
    d <- x$timeAtRisk
    row.names(d) <- "Days"
    printCoefmat(d)
  }
}

#' @export
coef.OutcomeModel <- function(object, ...) {
  return(object$outcomeModelTreatmentEstimate$logRr)
}

#' @export
confint.OutcomeModel <- function(object, parm, level = 0.95, ...) {
  missing(parm)  # suppresses R CMD check note
  if (level != 0.95)
    stop("Only supporting 95% confidence interval")
  return(c(object$outcomeModelTreatmentEstimate$logLb95,
           object$outcomeModelTreatmentEstimate$logUb95))
}

#' @export
print.OutcomeModel <- function(x, ...) {
  writeLines(paste("Model type:", x$outcomeModelType))
  writeLines(paste("Stratified:", x$outcomeModelStratified))
  writeLines(paste("Use covariates:", x$outcomeModelUseCovariates))
  writeLines(paste("Use inverse probability of treatment weighting:", x$inversePtWeighting))
  writeLines(paste("Status:", x$outcomeModelStatus))
  if (!is.null(x$outcomeModelPriorVariance) && !is.na(x$outcomeModelPriorVariance)) {
    writeLines(paste("Prior variance:", x$outcomeModelPriorVariance))
  }
  writeLines("")
  d <- x$outcomeModelTreatmentEstimate
  if (!is.null(d)) {
    rns <- "treatment"
    i <- x$outcomeModelInteractionEstimates
    if (!is.null(i)) {
      d <- rbind(d, i[,3:6])
      rns <-  c(rns, as.character(i$interactionName))
    }
    output <- data.frame(exp(d$logRr), exp(d$logLb95), exp(d$logUb95), d$logRr, d$seLogRr)
    colnames(output) <- c("Estimate", "lower .95", "upper .95", "logRr", "seLogRr")
    rownames(output) <- rns
    printCoefmat(output)
  }
}


#' Get the outcome model
#'
#' @description
#' Get the full outcome model, so showing the betas of all variables included
#' in the outcome model, not just the treatment variable.
#'
#' @param outcomeModel       An object of type `OutcomeModel` as generated using he
#'                           [fitOutcomeModel()] function.
#'
#' @template CohortMethodData
#'
#' @return
#' A tibble.
#'
#' @export
getOutcomeModel <- function(outcomeModel, cohortMethodData) {
  cfs <- outcomeModel$outcomeModelCoefficients

  cfs <- cfs[cfs != 0]
  attr(cfs, "names")[attr(cfs, "names") == "(Intercept)"] <- 0
  cfs <- data.frame(coefficient = cfs, id = as.numeric(attr(cfs, "names")))

  cfs <- merge(ff::as.ffdf(cfs),
               cohortMethodData$covariateRef,
               by.x = "id",
               by.y = "covariateId",
               all.x = TRUE)
  cfs <- ff::as.ram(cfs)
  cfs <- cfs[, c("coefficient", "id", "covariateName")]
  cfs$covariateName <- as.character(cfs$covariateName)
  if (length(cfs$coefficient) > 1) {
    cfs <- cfs[order(-abs(cfs$coefficient)), ]
  }
  cfs$covariateName[cfs$id == outcomeModel$outcomeModelTreatmentVarId] <- "Treatment"
  cfs$covariateName[cfs$id == 0] <- "Intercept"
  return(cfs)
}
