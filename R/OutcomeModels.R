# @file CohortMethod.R
#
# Copyright 2018 Observational Health Data Sciences and Informatics
#
# This file is part of CohortMethod
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#' Create an outcome model, and compute the relative risk
#'
#' @description
#' \code{fitOutcomeModel} creates an outcome model, and computes the relative risk
#'
#' @param population            A population object generated by \code{createStudyPopulation},
#'                              potentially filtered by other functions.
#'
#' @param cohortMethodData      An object of type \code{cohortMethodData} as generated using
#'                              \code{getDbCohortMethodData}.
#' @param modelType             The type of outcome model that will be used. Possible values are
#'                              "logistic", "poisson", or "cox".
#' @param stratified            Should the regression be conditioned on the strata defined in the
#'                              population object (e.g. by matching or stratifying on propensity
#'                              scores)?
#' @param useCovariates         Whether to use the covariate matrix in the \code{cohortMethodData}
#'                              object in the outcome model.
#' @param inversePsWeighting    Use inverse probability of treatment weigting?
#' @param excludeCovariateIds   Exclude these covariates from the outcome model.
#' @param includeCovariateIds   Include only these covariates in the outcome model.
#' @param prior                 The prior used to fit the model. See \code{\link[Cyclops]{createPrior}}
#'                              for details.
#' @param control               The control object used to control the cross-validation used to
#'                              determine the hyperparameters of the prior (if applicable). See
#'                              \code{\link[Cyclops]{createControl}} for details.
#' @param estimateHeterogeneity Whether to estimate potential heterogeneity in the treatment effect
#'                              as a function of covariates. Heterogeneity is estimated by
#'                              including the regression model interactions terms between
#'                              treatment and covariates.
#'
#' @return
#' An object of class \code{outcomeModel}. Generic function \code{summary}, \code{coef}, and
#' \code{confint} are available.
#'
#' @export
fitOutcomeModel <- function(population,
                            cohortMethodData,
                            modelType = "logistic",
                            stratified = TRUE,
                            useCovariates = TRUE,
                            inversePsWeighting = FALSE,
                            excludeCovariateIds = c(),
                            includeCovariateIds = c(),
                            prior = createPrior("laplace", useCrossValidation = TRUE),
                            control = createControl(cvType = "auto",
                                                    startingVariance = 0.01,
                                                    tolerance = 2e-07,
                                                    cvRepetitions = 10,
                                                    noiseLevel = "quiet"),
                            estimateHeterogeneity = FALSE) {
  if (stratified && is.null(population$stratumId))
    stop("Requested stratified analysis, but no stratumId column found in population. Please use matchOnPs or stratifyByPs to create strata.")
  if (is.null(population$outcomeCount))
    stop("No outcome variable found in population object. Use createStudyPopulation to create variable.")
  if (missing(cohortMethodData) && useCovariates)
    stop("Requested all covariates for model, but no cohortMethodData object specified")
  if (inversePsWeighting && is.null(population$propensityScore))
    stop("Requested inverse probability weighting, but no propensity scores are provided. Use createPs to generate them")
  if (modelType != "logistic" && modelType != "poisson" && modelType != "cox")
    stop(paste("Unknown modelType '",
                                modelType,
                                "', please choose either 'logistic', 'poisson', or 'cox'",
                                sep = ""))
  OhdsiRTools::logTrace("Fitting outcome model")

  start <- Sys.time()
  treatmentEstimate <- NULL
  coefficients <- NULL
  fit <- NULL
  priorVariance <- NULL
  treatmentVarId <- NA
  status <- "NO MODEL FITTED"

  colnames(population)[colnames(population) == "outcomeCount"] <- "y"
  if (!stratified) {
    population$stratumId <- NULL
  }
  if (modelType == "cox") {
    population$y[population$y != 0] <- 1
    population$time <- population$survivalTime
  } else if (modelType == "logistic") {
    population$y[population$y != 0] <- 1
  } else if (modelType == "poisson") {
    population$time <- population$timeAtRisk
  }
  populationCounts <- getCounts(population, "Population count")
  outcomeCounts <- data.frame(treatedPersons = length(unique(population$subjectId[population$treatment == 1 & population$y != 0])),
                              comparatorPersons = length(unique(population$subjectId[population$treatment == 0 & population$y != 0])),
                              treatedExposures = length(population$subjectId[population$treatment == 1 & population$y != 0]),
                              comparatorExposures = length(population$subjectId[population$treatment == 0 & population$y != 0]),
                              treatedOutcomes = sum(population$y[population$treatment == 1]), comparatorOutcomes = sum(population$y[population$treatment == 0]))
  outcomeCounts <- outcomeCounts
  if (modelType == "poisson" || modelType == "cox") {
    timeAtRisk <- data.frame(treatedDays = sum(population$time[population$treatment == 1]),
                             comparatorDays = sum(population$time[population$treatment == 0]))
  }

  if (nrow(population) == 0) {
    status <- "NO SUBJECTS IN POPULATION, CANNOT FIT"
  } else if (sum(population$y) == 0) {
    status <- "NO OUTCOMES FOUND FOR POPULATION, CANNOT FIT"
  } else {
    if (useCovariates || estimateHeterogeneity) {
      covariates <- FeatureExtraction::filterByRowId(cohortMethodData$covariates, ff::as.ff(population$rowId))
      if (length(includeCovariateIds) != 0) {
        includeCovariateIds <- c(includeCovariateIds, treatmentVarId)
        idx <- !is.na(ffbase::ffmatch(covariates$covariateId, ff::as.ff(includeCovariateIds)))
        covariates <- covariates[ffbase::ffwhich(idx, idx == TRUE), ]
      }
      if (length(excludeCovariateIds) != 0) {
        idx <- is.na(ffbase::ffmatch(covariates$covariateId, ff::as.ff(excludeCovariateIds)))
        covariates <- covariates[ffbase::ffwhich(idx, idx == TRUE), ]
      }
      covariateData <- FeatureExtraction::tidyCovariateData(covariates = covariates,
                                                            covariateRef = cohortMethodData$covariateRef,
                                                            populationSize = nrow(population),
                                                            normalize = TRUE,
                                                            removeRedundancy = TRUE)
      covariates <- covariateData$covariates
      attr(population, "metaData")$deletedCovariateIdsforOutcomeModel <- covariateData$metaData$deletedCovariateIds
      rm(covariateData)
      treatmentVarId <- ffbase::max.ff(cohortMethodData$covariates$covariateId) + 1
      if (stratified || modelType == "cox") {
        prior$exclude <- treatmentVarId  # Exclude treatment variable from regularization
      } else {
        prior$exclude <- c(0, treatmentVarId)  # Exclude treatment variable and intercept from regularization
      }
      treatmentCovariate <- ff::ffdf(rowId = ff::as.ff(population$rowId),
                                     covariateId = ff::ff(treatmentVarId,
                                                          length = nrow(population),
                                                          vmode = "double"),
                                     covariateValue = ff::as.ff(population$treatment,
                                                                vmode = "double"))
      if (estimateHeterogeneity) {
        covariateIdOffset <- treatmentVarId + 1
        interactions <- createInteractionWithTreatment(covariates, population, covariateIdOffset)
        interactionCovariatesId <- unique(interactions$covariateId[])
        if (useCovariates) {
          covariates <- ffbase::ffappend(interactions, covariates)
        } else {
          covariates <- interactions
        }
      }
      covariates <- ffbase::ffdfappend(treatmentCovariate, covariates)
      if (stratified) {
        informativeStrata <- unique(population$stratumId[population$y != 0])
        population <- population[population$stratumId %in% informativeStrata, ]
        covariates <- ffbase::merge.ffdf(covariates,
                                         ff::as.ffdf(population[, c("rowId", "stratumId")]))
      }
    } else {
      prior <- createPrior("none")  # Only one variable, which we're not going to regularize, so effectively no prior
      treatmentVarId <- 1
      covariates <- ff::ffdf(rowId = ff::as.ff(population$rowId),
                             covariateId = ff::ff(treatmentVarId, length = nrow(population)),
                             covariateValue = ff::as.ff(population$treatment),
                             row.names = row.names(population))
      if (stratified) {
        covariates$stratumId <- ff::as.ff(population$stratumId)
      }
    }
    if (stratified || modelType == "cox") {
      addIntercept <- FALSE
    } else {
      addIntercept <- TRUE
    }
    if (inversePsWeighting) {
      population$weight <- population$treatment / population$propensityScore + (1-population$treatment) / (1-population$propensityScore)
    } else {
      population$weight <- NULL
    }
    outcomes <- ff::as.ffdf(population)
    cyclopsData <- Cyclops::convertToCyclopsData(outcomes = outcomes,
                                                 covariates = covariates,
                                                 addIntercept = addIntercept,
                                                 modelType = modelTypeToCyclopsModelType(modelType,
                                                                                         stratified),
                                                 checkSorting = TRUE,
                                                 checkRowIds = FALSE,
                                                 normalize = NULL,
                                                 quiet = TRUE)
    ff::close.ffdf(outcomes)
    ff::close.ffdf(covariates)
    rm(outcomes)
    rm(covariates)
    if (prior$priorType != "none" && prior$useCrossValidation && control$selectorType == "byPid" &&
        length(unique(population$stratumId)) < control$fold) {
      fit <- "NUMBER OF INFORMATIVE STRATA IS SMALLER THAN THE NUMBER OF CV FOLDS, CANNOT FIT"
    } else {
      fit <- tryCatch({
        Cyclops::fitCyclopsModel(cyclopsData, prior = prior, control = control)
      }, error = function(e) {
        e$message
      })
    }
    if (is.character(fit)) {
      status <- fit
    } else if (fit$return_flag == "ILLCONDITIONED") {
      status <- "ILL CONDITIONED, CANNOT FIT"
    } else if (fit$return_flag == "MAX_ITERATIONS") {
      status <- "REACHED MAXIMUM NUMBER OF ITERATIONS, CANNOT FIT"
    } else {
      status <- "OK"
      coefficients <- coef(fit)
      logRr <- coef(fit)[names(coef(fit)) == as.character(treatmentVarId)]
      nonzeroCoef <- coefficients[coefficients != 0]
      heterogeneityCoefId <- intersect(names(nonzeroCoef), as.character(interactions$covariateId[]))
        # TODO: discuss if `as.character` is a reliable way to subset the vector; seems like it will fail when the id numbers become large.
      heterogeneityCoef <- nonzeroCoef[match(heterogeneityCoefId, names(nonzeroCoef))]
      heterogeneityCoefId <- as.numeric(heterogeneityCoefId)
      ff::close.ffdf(interactions)
      rm(interactions)
      ci <- tryCatch({
        confint(fit, parm = treatmentVarId, includePenalty = TRUE)
      }, error = function(e) {
        missing(e)  # suppresses R CMD check note
        c(0, -Inf, Inf)
      })
      if (identical(ci, c(0, -Inf, Inf)))
        status <- "ERROR COMPUTING CI"
      seLogRr <- (ci[3] - ci[2])/(2 * qnorm(0.975))
      treatmentEstimate <- data.frame(logRr = logRr,
                                      logLb95 = ci[2],
                                      logUb95 = ci[3],
                                      seLogRr = seLogRr)
      priorVariance <- fit$variance[1]
    }
  }
  outcomeModel <- attr(population, "metaData")
  outcomeModel$outcomeModelTreatmentVarId <- treatmentVarId
  outcomeModel$outcomeModelCoefficients <- coefficients
  outcomeModel$outcomeModelPriorVariance <- priorVariance
  outcomeModel$outcomeModelType <- modelType
  outcomeModel$outcomeModelStratified <- stratified
  outcomeModel$outcomeModelUseCovariates <- useCovariates
  outcomeModel$inversePsWeighting <- inversePsWeighting
  outcomeModel$outcomeModelTreatmentEstimate <- treatmentEstimate
  outcomeModel$outcomeModelTreatmentHeterogeneityCoef <- heterogeneityCoef
  outcomeModel$outcomeModelTreatmentHeterogeneityCoefId <- heterogeneityCoefId
  outcomeModel$outcomeModelStatus <- status
  outcomeModel$populationCounts <- populationCounts
  outcomeModel$outcomeCounts <- outcomeCounts
  if (modelType == "poisson" || modelType == "cox") {
    outcomeModel$timeAtRisk <- timeAtRisk
  }
  class(outcomeModel) <- "outcomeModel"
  delta <- Sys.time() - start
  OhdsiRTools::logInfo(paste("Fitting outcome model took", signif(delta, 3), attr(delta, "units")))
  OhdsiRTools::logDebug("Outcome model fitting status is: ", status)
  return(outcomeModel)
}

createInteractionWithTreatment <- function (covariates, population, covariateIdOffset) {
  matchedRowId <- match(covariates$rowId[], population$rowId)
  covariateValue <- population$treatment[matchedRowId] * covariates$covariateValue[]
  nonzeroIndices <- which(covariateValue != 0)
  interactionCovariate <- ff::ffdf(
    rowId = ff::as.ff(
      covariates$rowId[nonzeroIndices],
      vmode = "double"
    ),
    covariateId = ff::as.ff(
      covariateIdOffset + covariates$covariateId[nonzeroIndices],
      vmode = "double"
    ),
    covariateValue = ff::as.ff(
      covariateValue[nonzeroIndices],
      vmode = "double"
    )
  )
  return(interactionCovariate)
}

modelTypeToCyclopsModelType <- function(modelType, stratified) {
  if (modelType == "logistic") {
    if (stratified)
      return("clr") else return("lr")
  } else if (modelType == "poisson") {
    if (stratified)
      return("cpr") else return("pr")
  } else if (modelType == "cox") {
    return("cox")
  } else stop(paste("Unknown model type:", modelType))
}

#' @export
summary.outcomeModel <- function(object, ...) {
  class(object) <- "summary.outcomeModel"
  return(object)
}

#' @export
print.summary.outcomeModel <- function(x, ...) {
  print.outcomeModel(x)

  writeLines("")
  writeLines("Population counts")
  d <- x$populationCounts
  row.names(d) <- "Count"
  d$description <- NULL
  printCoefmat(d)

  writeLines("")
  writeLines("Outcome counts")
  d <- x$outcomeCounts
  row.names(d) <- "Count"
  if (x$outcomeModelType != "poisson") {
    d$treatedOutcomes <- NULL
    d$comparatorOutcomes <- NULL
  }
  printCoefmat(d)

  if (x$outcomeModelType == "poisson" || x$outcomeModelType == "cox") {
    writeLines("")
    writeLines("Time at risk")
    d <- x$timeAtRisk
    row.names(d) <- "Days"
    printCoefmat(d)
  }
}

#' @export
coef.outcomeModel <- function(object, ...) {
  return(object$outcomeModelTreatmentEstimate$logRr)
}

#' @export
confint.outcomeModel <- function(object, parm, level = 0.95, ...) {
  missing(parm)  # suppresses R CMD check note
  if (level != 0.95)
    stop("Only supporting 95% confidence interval")
  return(c(object$outcomeModelTreatmentEstimate$logLb95,
           object$outcomeModelTreatmentEstimate$logUb95))
}

#' @export
print.outcomeModel <- function(x, ...) {
  writeLines(paste("Model type:", x$outcomeModelType))
  writeLines(paste("Stratified:", x$outcomeModelStratified))
  writeLines(paste("Use covariates:", x$outcomeModelUseCovariates))
  writeLines(paste("Use inverse probability of treatment weighting:", x$inversePsWeighting))
  writeLines(paste("Status:", x$outcomeModelStatus))
  if (!is.null(x$outcomeModelPriorVariance) && !is.na(x$outcomeModelPriorVariance)) {
    writeLines(paste("Prior variance:", x$outcomeModelPriorVariance))
  }
  writeLines("")
  d <- x$outcomeModelTreatmentEstimate
  if (!is.null(d)) {
    output <- data.frame(exp(d$logRr), exp(d$logLb95), exp(d$logUb95), d$logRr, d$seLogRr)
    colnames(output) <- c("Estimate", "lower .95", "upper .95", "logRr", "seLogRr")
    rownames(output) <- "treatment"
    printCoefmat(output)
  }
}

#' Get the outcome model
#'
#' @description
#' \code{getOutcomeModel} shows the full outcome model, so showing the betas of all variables included
#' in the outcome model, not just the treatment variable.
#'
#' @param outcomeModel       An object of type \code{outcomeModel} as generated using he
#'                           \code{createOutcomeMode} function.
#' @param cohortMethodData   An object of type \code{cohortMethodData} as generated using
#'                           \code{getDbCohortMethodData}.
#'
#' @details
#' Shows the coefficients and names of the covariates with non-zero coefficients.
#'
#' @examples
#' # todo
#'
#' @export
getOutcomeModel <- function(outcomeModel, cohortMethodData) {
  cfs <- outcomeModel$outcomeModelCoefficients

  cfs <- cfs[cfs != 0]
  attr(cfs, "names")[attr(cfs, "names") == "(Intercept)"] <- 0
  cfs <- data.frame(coefficient = cfs, id = as.numeric(attr(cfs, "names")))

  cfs <- merge(ff::as.ffdf(cfs),
               cohortMethodData$covariateRef,
               by.x = "id",
               by.y = "covariateId",
               all.x = TRUE)
  cfs <- ff::as.ram(cfs)
  cfs <- cfs[, c("coefficient", "id", "covariateName")]
  cfs$covariateName <- as.character(cfs$covariateName)
  if (length(cfs$coefficient) > 1) {
    cfs <- cfs[order(-abs(cfs$coefficient)), ]
  }
  cfs$covariateName[cfs$id == outcomeModel$outcomeModelTreatmentVarId] <- "Treatment"
  cfs$covariateName[cfs$id == 0] <- "Intercept"
  return(cfs)
}
