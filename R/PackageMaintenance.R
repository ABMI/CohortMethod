# @file PackageMaintenance
#
# Copyright 2015 Observational Health Data Sciences and Informatics
#
# This file is part of CohortMethod
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

.formatAndCheckCode <- function() {
  OhdsiRTools::formatRFolder()
  OhdsiRTools::checkUsagePackage("CohortMethod")
  OhdsiRTools::ohdsiLintrFolder()
}

.createManualAndVignettes <- function() {
  shell("rm extras/CohortMethod.pdf")
  shell("R CMD Rd2pdf ./ --output=extras/CohortMethod.pdf")

  rmarkdown::render("vignettes/SingleStudies.Rmd",
                    output_file = "../inst/doc/SingleStudies.pdf",
                    rmarkdown::pdf_document(latex_engine = "pdflatex",
                                            toc = TRUE,
                                            number_sections = TRUE))
}

.createArgFunctions <- function(){
  rCode <- c("# This file has been autogenerated. Do not change by hand. ")
  rCode <- createArgFunction("getDbCohortMethodData", excludeArgs = c("connectionDetails","cdmDatabaseSchema","oracleTempSchema", "exposureDatabaseSchema", "exposureTable", "outcomeDatabaseSchema", "outcomeTable", "targetDrugConceptId", "comparatorDrugConceptId", "indicationConceptIds", "outcomeConceptIds", "exclusionConceptIds"), rCode = rCode)
  rCode <- createArgFunction("createPs", excludeArgs = c("cohortMethodData","outcomeConceptId"), rCode = rCode)
  rCode <- createArgFunction("trimByPs", excludeArgs = c("data"), rCode = rCode)
  rCode <- createArgFunction("trimByPsToEquipoise", excludeArgs = c("data"), rCode = rCode)
  rCode <- createArgFunction("matchOnPsAndCovariates", excludeArgs = c("data", "cohortMethodData"), rCode = rCode)
  rCode <- createArgFunction("stratifyByPsAndCovariates", excludeArgs = c("data", "cohortMethodData"), rCode = rCode)
  rCode <- createArgFunction("fitOutcomeModel", excludeArgs = c("outcomeConceptId","cohortMethodData","subPopulation"), rCode = rCode)
  writeLines(rCode, "r/CreateArgFunctions.R")
  OhdsiRTools::formatRFile("r/CreateArgFunctions.R")
}

createArgFunction <- function(fun, excludeArgs = c(), includeArgs = NULL, rCode = c(), newName = NULL){
  args <- formals(fun)
  if (!is.null(includeArgs)){
    args <- args[names(args) %in% includeArgs]
  }
  args <- args[!(names(args) %in% excludeArgs)]
  toChar <- function(x) {
    if (is.null(x)) {
      "NULL"
    } else if (class(x) == "call") {
      paste(capture.output(x),collapse="")
    } else if (class(x) == "character") {
      paste("\"",x,"\"",sep="")
    } else {
      as.character(x)
    }
  }
  args <- sapply(args,toChar)
  argInfo <- data.frame(name = names(args))
  argInfo$default <- NULL
  for (i in 1 : length(args)){
    argInfo$default[argInfo$name == names(args)[[i]]] <- args[[i]]
  }
  html <- capture.output(tools::Rd2HTML(utils:::.getHelpFile(help(fun))))
  xmlValue <- NULL
  parameterHelp <- XML::xpathApply(XML::htmlParse(html), '//table[@summary=\"R argblock\"]//tr//td', XML::xmlValue)
  argInfo$help <- NULL
  for (i in 1 : (length(parameterHelp) / 2)){
    argInfo$help[argInfo$name == parameterHelp[[i*2 - 1]]] <- gsub("\n","",parameterHelp[[i*2]])
  }

  if (length(rCode) != 0) {
    rCode <- c(rCode, "")
  }
  rCode <- c(rCode, paste("#' Create parameter object for the function",fun))
  rCode <- c(rCode, "#'")
  rCode <- c(rCode, "#' @details")
  rCode <- c(rCode, "#' Create an object defining the parameter values. To be used in the \\code{\\link{createCohortMethodAnalysis}} function.")
  rCode <- c(rCode, "#'")
  for (i in 1:nrow(argInfo)){
    rCode <- c(rCode, paste("#' @param",argInfo$name[i],argInfo$help[i]))
  }
  rCode <- c(rCode, "#'")
  rCode <- c(rCode, "#' @export")
  if (is.null(newName)){
    createFunArgsName <- paste("create", toupper(substr(fun,1,1)), substr(fun,2,nchar(fun)), "Args", sep = "")
  } else {
    createFunArgsName <- newName
  }
  header <- paste(createFunArgsName, "<- function(")
  for (i in 1:nrow(argInfo)){
    if (i == 1){
      start = header
    } else {
      start = paste(rep(" ",nchar(header)), collapse="")
    }
    if (argInfo$default[i] == ""){
      end = ""
    } else {
      end = paste(" = ", argInfo$default[i], sep="")
    }
    if (i == nrow(argInfo)) {
      end <- paste(end,") {",sep="")
    } else {
      end <- paste(end,",",sep="")
    }

    rCode <- c(rCode, paste(start, argInfo$name[i], end, sep = ""))
  }
  rCode <- c(rCode, "  #First: get default values:")
  rCode <- c(rCode, "  analysis <- list()")
  rCode <- c(rCode, paste("  for (name in names(formals(",createFunArgsName,"))){",sep=""))
  rCode <- c(rCode, "    analysis[[name]] = get(name)")
  rCode <- c(rCode, "  }")
  rCode <- c(rCode, "  #Second: overwrite defaults with actual values:")
  rCode <- c(rCode, "  values <- lapply(as.list(match.call())[-1],function(x) eval(x,envir=sys.frame(-3)))")
  rCode <- c(rCode, "  for (name in names(values)){")
  rCode <- c(rCode, "    if (name %in% names(analysis))")
  rCode <- c(rCode, "      analysis[[name]] = values[[name]]")
  rCode <- c(rCode, "  }")
  #rCode <- c(rCode, paste("  attr(analysis, \"function\") <- \"", fun, "\"", sep = ""))
  #rCode <- c(rCode, "  attr(analysis, \"userSpecified\") <- names(values)")
  #rCode <- c(rCode, "packages <- installed.packages()")
  #rCode <- c(rCode, "attr(values, \"version\") <- packages[packages[,\"Package\"] == \"CohortMethod\",\"Version\"]")
  rCode <- c(rCode, "  class(analysis) <- \"args\"")
  rCode <- c(rCode, "  return(analysis)")
  rCode <- c(rCode, "}")
  return(rCode)
}

.recursivePrettyPrint <- function(object, name, indent) {
  name <- paste(paste(rep(" ",indent),collapse=""),name,sep="")
  if (is.list(object)) {
    writeLines(name)
    for (i in 1:length(object)) {
      .recursivePrettyPrint(object[[i]], names(object)[i], indent + 2)
    }
  } else if (is.character(object)) {
    writeLines(paste(name, paste("\"",object,"\"",sep=""), sep = " = "))
  } else if (is.vector(object)) {
    writeLines(substr(paste(name, paste(object,collapse=", "), sep = " = "),1,100))
  }else{
    writeLines(paste(name, object, sep = " = "))
  }
}

#' @export
prettyPrint <- function(object) {
  .recursivePrettyPrint(object, "", 0)
}

#' @export
selectFromList <- function(x, select){
  return(sapply(x, function(x){x[names(x)[names(x) %in% select]]}, simplify = FALSE))
}

#' @export
excludeFromList <- function(x, exclude){
  return(sapply(x, function(x){x[names(x)[!(names(x) %in% exclude)]]}, simplify = FALSE))
}

#' @export
matchInList <- function(x, toMatch){
  selected <- selectFromList(x, names(toMatch))
  result <- list()
  for (i in 1:length(x)){
    if (identical(selected[[i]], toMatch)) {
      result[[length(result) + 1]] <- x[[i]]
    }
  }
  return(result)
}


.computeFfMemPerCluster <- function(nClusters){
  # memory.limit is windows specific
  if (.Platform$OS.type=="windows") {
    if (getRversion()>="2.6.0")  # memory.limit was silently changed from 2.6.0 to return in MB instead of bytes
      ffmaxbytes = 0.5*memory.limit()*(1024^2)
    else
      ffmaxbytes = 0.5*memory.limit()
  } else {
    # some magic constant (2GB)
    ffmaxbytes=2*1024^3
  }
  ffmaxbytes = ffmaxbytes / nClusters
  #Limit size on machines with a lot of memory to prevent integer overflows in ff:
  ffmaxbytes = min(ffmaxbytes,.Machine$integer.max * 12)

  ffbatchbytes = ffmaxbytes/50;
  return(c(round(ffmaxbytes),round(ffbatchbytes)))
}

#' @export
makeCluster <- function(numberOfThreads, singleThreadToMain = TRUE){
  if (numberOfThreads == 1 && singleThreadToMain){
    cluster <- list()
    class(cluster) <- "noCluster"
  } else {
    cluster <- snow::makeCluster(numberOfThreads, type = "SOCK")
  }
  return(cluster)
}

#' @export
clusterRequire <- function(cluster, package){
  if (class(cluster)[1] == "noCluster"){
    do.call("require", list(package = package))
  } else {
    requirePackage <- function(package){
      do.call("require", list(package = package))
    }
    for (i in 1:length(cluster)){
      snow::sendCall(cluster[[i]], requirePackage, list(package = package))
    }
    for (i in 1:length(cluster)){
      snow::recvOneResult(cluster)
    }
  }
}

#' @export
stopCluster <- function(cluster){
  if (class(cluster)[1] != "noCluster"){
    snow::stopCluster.default(cluster)
  }
}

#' @export
clusterApply <- function (cluster, x, fun, ..., stopOnError = FALSE, progressBar = TRUE, divideFfMemory = TRUE, setFfTempDir = TRUE){
  if (class(cluster)[1] == "noCluster"){
    lapply(x, fun, ...)
  } else {
    if (divideFfMemory){
      values = .computeFfMemPerCluster(length(cluster))
      setFfMem <- function(values){
        options(ffmaxbytes = values[1])
        options(ffbatchbytes = values[2])
        return(c(getOption("ffmaxbytes"),getOption("ffbatchbytes")))
      }
      for (i in 1:length(cluster)){
        snow::sendCall(cluster[[i]], setFfMem, list(values = values))
      }
      for (i in 1:length(cluster)){
        if (min(snow::recvOneResult(cluster)$value == values) == 0)
          warning("Unable to set ffmaxbytes and/or ffbatchbytes on worker")
      }
    }
    if (setFfTempDir){
      setFfDir <- function(fftempdir) {
        options("fftempdir" = fftempdir)
      }
      for (i in 1:length(cluster)){
        snow::sendCall(cluster[[i]], setFfDir, list(fftempdir = options("fftempdir")$fftempdir))
      }
      for (i in 1:length(cluster)){
        snow::recvOneResult(cluster)
      }
    }

    argfun <- function(i) c(list(x[[i]]), list(...))
    n <- length(x)
    p <- length(cluster)
    if (n > 0 && p > 0) {
      if (progressBar)
        pb <- txtProgressBar(style=3)

      submit <- function(node, job) snow::sendCall(cluster[[node]], fun,
                                                   argfun(job), tag = job)
      for (i in 1:min(n, p)) submit(i, i)
      val <- vector("list", n)
      errors <- c(paste("Error(s) when calling function ",substitute(fun,parent.frame(1)),":",sep = ""))
      formatError <- function(error,args){
        paste("\nError \"",error[[1]],"\" when using argument(s): ",paste(args,collapse=","),sep="")
      }
      for (i in 1:n) {
        d <- snow::recvOneResult(cluster)
        if (inherits(d$value, "try-error")){
          val[d$tag] <- NULL
          errors <- c(errors, formatError(d$value, argfun(d$tag)))
          if (stopOnError)
            stop(paste(errors,collapse=""), call. = FALSE)
        }
        if (progressBar)
          setTxtProgressBar(pb, i/n)
        j <- i + min(n, p)
        if (j <= n)
          snow::submit(d$node, j)
        val[d$tag] <- list(d$value)
      }
      if (progressBar)
        close(pb)
      if (length(errors) != 1)
        stop(paste(errors,collapse=""), call. = FALSE)
      return(val)
    }
  }
}
